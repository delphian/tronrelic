name: Main-PR Environment

on:
  pull_request:
    branches:
      - main

jobs:
  test:
    name: Run All Tests
    uses: ./.github/workflows/test.yml
    secrets: inherit

  build-and-provision:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull private submodules (optional)
        run: |
          # Rewrite SSH URLs to HTTPS for token authentication (CI/CD only)
          git config --global url."https://github.com/".insteadOf "git@github.com:"

          # Create credential helper script that returns the token
          cat > /tmp/git-askpass.sh <<'SCRIPT'
          #!/bin/sh
          case "$1" in
            Username*) echo "x-access-token" ;;
            Password*) echo "$GH_PRIVATE_SUBMODULE_TOKEN" ;;
          esac
          SCRIPT
          chmod +x /tmp/git-askpass.sh

          # Use credential helper for submodule checkout
          GIT_ASKPASS=/tmp/git-askpass.sh git submodule update --init --recursive || true
        env:
          GH_PRIVATE_SUBMODULE_TOKEN: ${{ secrets.GH_PRIVATE_SUBMODULE_TOKEN || '' }}
        continue-on-error: true

      - name: Prepare image tag
        id: prep
        run: |
          SHORT_SHA=$(echo "${{ github.event.pull_request.head.sha }}" | cut -c1-7)
          IMAGE_TAG="dev-${SHORT_SHA}"
          DROPLET_NAME="tronrelic-main-pr-${{ github.event.pull_request.number }}"

          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "droplet_name=$DROPLET_NAME" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Image tag: $IMAGE_TAG"
          echo "ðŸ–¥ï¸ Droplet name: $DROPLET_NAME"

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        run: |
          docker build --target backend \
            -t ghcr.io/${{ github.repository }}/backend:${{ steps.prep.outputs.tag }} \
            .
          docker push ghcr.io/${{ github.repository }}/backend:${{ steps.prep.outputs.tag }}

      - name: Build and push frontend image
        run: |
          docker build --target frontend-prod \
            -t ghcr.io/${{ github.repository }}/frontend:${{ steps.prep.outputs.tag }} \
            .
          docker push ghcr.io/${{ github.repository }}/frontend:${{ steps.prep.outputs.tag }}

      - name: Images built successfully
        run: |
          echo "âœ… Dev branch Docker images built and pushed to GHCR"
          echo ""
          echo "Branch: dev"
          echo "Commit: ${{ github.sha }}"
          echo "Image tag: ${{ steps.prep.outputs.tag }}"
          echo ""
          echo "Backend: ghcr.io/${{ github.repository }}/backend:${{ steps.prep.outputs.tag }}"
          echo "Frontend: ghcr.io/${{ github.repository }}/frontend:${{ steps.prep.outputs.tag }}"

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Check if droplet already exists
        id: check
        run: |
          DROPLET_NAME="${{ steps.prep.outputs.droplet_name }}"

          if doctl compute droplet list --format Name --no-header | grep -q "^${DROPLET_NAME}$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ Droplet $DROPLET_NAME already exists, skipping creation"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âœ… Droplet $DROPLET_NAME does not exist, will create"
          fi

      - name: Check if reserved IP is available
        if: steps.check.outputs.exists == 'false'
        id: check_ip
        run: |
          RESERVED_IP="${{ secrets.DO_DEV_IP }}"

          echo "Checking if reserved IP is available: $RESERVED_IP"

          # Get droplet ID that currently has this reserved IP
          EXISTING_DROPLET_ID=$(doctl compute floating-ip get "$RESERVED_IP" --format DropletID --no-header 2>/dev/null || echo "")

          if [ -n "$EXISTING_DROPLET_ID" ] && [ "$EXISTING_DROPLET_ID" != "0" ]; then
            # Get droplet name
            EXISTING_DROPLET_NAME=$(doctl compute droplet get "$EXISTING_DROPLET_ID" --format Name --no-header 2>/dev/null || echo "unknown")

            echo "âš ï¸ Reserved IP is currently attached to droplet: $EXISTING_DROPLET_NAME (ID: $EXISTING_DROPLET_ID)"
            echo "âš ï¸ Will use dynamic IP instead"
            echo "ip_available=false" >> $GITHUB_OUTPUT
            echo "conflicting_droplet=$EXISTING_DROPLET_NAME" >> $GITHUB_OUTPUT
          else
            echo "âœ… Reserved IP is available"
            echo "ip_available=true" >> $GITHUB_OUTPUT
          fi

      - name: Create droplet
        if: steps.check.outputs.exists == 'false'
        id: create
        run: |
          DROPLET_NAME="${{ steps.prep.outputs.droplet_name }}"

          echo "Creating droplet: $DROPLET_NAME"

          doctl compute droplet create "$DROPLET_NAME" \
            --size s-2vcpu-4gb-amd \
            --region sgp1 \
            --image ubuntu-25-04-x64 \
            --ssh-keys ${{ secrets.DO_SSH_KEY_FINGERPRINT }} \
            --tag-names "tronrelic-main-pr-testing" \
            --wait \
            --format ID,Name,PublicIPv4 \
            --no-header

          echo "âœ… Droplet created successfully"
          echo "Waiting for droplet initialization to complete..."
          sleep 15

      - name: Get droplet public IP
        if: steps.check.outputs.exists == 'false'
        id: get_ip
        run: |
          DROPLET_NAME="${{ steps.prep.outputs.droplet_name }}"

          # Wait a moment for droplet to be fully ready
          sleep 10

          DROPLET_IP=$(doctl compute droplet list \
            --format Name,PublicIPv4 \
            --no-header \
            | grep "^${DROPLET_NAME}" \
            | awk '{print $2}')

          if [ -z "$DROPLET_IP" ]; then
            echo "âŒ Could not retrieve droplet IP"
            exit 1
          fi

          echo "ip=$DROPLET_IP" >> $GITHUB_OUTPUT
          echo "âœ… Droplet public IP: $DROPLET_IP"

      - name: Assign reserved IP to droplet
        if: steps.check.outputs.exists == 'false' && steps.check_ip.outputs.ip_available == 'true'
        id: assign_ip
        run: |
          DROPLET_NAME="${{ steps.prep.outputs.droplet_name }}"
          RESERVED_IP="${{ secrets.DO_DEV_IP }}"

          # Get droplet ID
          DROPLET_ID=$(doctl compute droplet list --format ID,Name --no-header | grep "$DROPLET_NAME" | awk '{print $1}')

          if [ -z "$DROPLET_ID" ]; then
            echo "âŒ Could not find droplet ID for $DROPLET_NAME"
            exit 1
          fi

          echo "Assigning reserved IP $RESERVED_IP to droplet $DROPLET_NAME (ID: $DROPLET_ID)..."

          doctl compute floating-ip-action assign "$RESERVED_IP" "$DROPLET_ID"

          echo "Waiting for IP assignment to complete..."
          sleep 10

          echo "âœ… Reserved IP assigned: $RESERVED_IP"

      - name: Set droplet access info
        if: steps.check.outputs.exists == 'false'
        id: ip
        run: |
          if [ "${{ steps.check_ip.outputs.ip_available }}" == "true" ]; then
            DROPLET_IP="${{ secrets.DO_DEV_IP }}"
            DOMAIN="${{ secrets.DO_DEV_HOST }}"
            echo "using_reserved_ip=true" >> $GITHUB_OUTPUT
          else
            DROPLET_IP="${{ steps.get_ip.outputs.ip }}"
            DOMAIN=""
            echo "using_reserved_ip=false" >> $GITHUB_OUTPUT
          fi

          echo "ip=$DROPLET_IP" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "âœ… Droplet accessible at: $DROPLET_IP"

      - name: Install Docker on droplet
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"

          echo "Setting up SSH key..."
          mkdir -p ~/.ssh
          echo "${{ secrets.DO_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          echo "Waiting for SSH to become available..."
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no root@"$DROPLET_IP" "echo 'SSH Ready'" 2>/dev/null; then
              echo "âœ… SSH connection established"
              break
            fi

            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - waiting 10s..."
            sleep 10
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "âŒ SSH did not become available in time"
            exit 1
          fi

          echo "Adding droplet to known_hosts..."
          ssh-keyscan -H "$DROPLET_IP" >> ~/.ssh/known_hosts

          echo "Installing Docker and dependencies..."
          ssh root@"$DROPLET_IP" << 'EOF'
            set -e

            # Wait for apt locks to be released (fresh droplets often have unattended-upgrades running)
            echo "Waiting for apt locks to be released..."
            MAX_WAIT=300
            ELAPSED=0
            while fuser /var/lib/apt/lists/lock >/dev/null 2>&1 || fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 ; do
                echo "Waiting for other apt processes to finish... ($ELAPSED seconds elapsed)"
                sleep 10
                ELAPSED=$((ELAPSED + 10))
                if [ $ELAPSED -ge $MAX_WAIT ]; then
                    echo "Timeout waiting for apt lock - killing background processes"
                    killall -9 apt-get apt || true
                    sleep 5
                    break
                fi
            done
            echo "Apt locks released, proceeding with installation"

            # Update package index
            apt-get update

            # Install prerequisites
            apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release

            # Add Docker's official GPG key
            install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
            chmod a+r /etc/apt/keyrings/docker.asc

            # Add Docker repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
              $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
              tee /etc/apt/sources.list.d/docker.list > /dev/null

            # Install Docker Engine
            apt-get update
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

            # Start and enable Docker
            systemctl start docker
            systemctl enable docker

            # Create deployment directory
            mkdir -p /opt/tronrelic

            # Verify installation
            docker --version
            docker compose version

            echo "âœ… Docker installation complete"
          EOF

          echo "âœ… Droplet setup complete"

      - name: Install and configure Nginx with self-signed SSL
        if: steps.check.outputs.exists == 'false' && steps.ip.outputs.using_reserved_ip == 'true'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"
          DOMAIN="${{ steps.ip.outputs.domain }}"

          echo "Installing Nginx..."
          ssh root@"$DROPLET_IP" << 'EOF'
            set -e

            # Install Nginx
            apt-get install -y nginx

            # Start and enable Nginx
            systemctl start nginx
            systemctl enable nginx

            echo "âœ… Nginx installed"
          EOF

          echo "Generating self-signed SSL certificate..."

          ssh root@"$DROPLET_IP" << SSLEOF
            set -e

            # Create directory for SSL certificates
            mkdir -p /etc/nginx/ssl

            # Generate self-signed certificate (valid for 30 days)
            openssl req -x509 -nodes -days 30 -newkey rsa:2048 \
              -keyout /etc/nginx/ssl/selfsigned.key \
              -out /etc/nginx/ssl/selfsigned.crt \
              -subj "/C=US/ST=Dev/L=Dev/O=TronRelic/CN=$DOMAIN"

            chmod 600 /etc/nginx/ssl/selfsigned.key
            chmod 644 /etc/nginx/ssl/selfsigned.crt

            echo "âœ… Self-signed certificate generated"
          SSLEOF

          echo "Creating Nginx configuration with self-signed SSL..."

          cat > /tmp/nginx-ssl.conf <<'LOCALEOF'
          server {
              listen 80;
              listen [::]:80;
              server_name DOMAIN_PLACEHOLDER;

              location / {
                  return 301 https://$server_name$request_uri;
              }
          }

          server {
              listen 443 ssl http2;
              listen [::]:443 ssl http2;
              server_name DOMAIN_PLACEHOLDER;

              ssl_certificate /etc/nginx/ssl/selfsigned.crt;
              ssl_certificate_key /etc/nginx/ssl/selfsigned.key;
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers HIGH:!aNULL:!MD5;
              ssl_prefer_server_ciphers on;

              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;

              client_max_body_size 100m;
              proxy_read_timeout 300s;
              proxy_connect_timeout 75s;

              location /api {
                  proxy_pass http://127.0.0.1:4000;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              location /socket.io {
                  proxy_pass http://127.0.0.1:4000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_cache_bypass $http_upgrade;
              }

              location / {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }
          LOCALEOF

          sed -i "s/DOMAIN_PLACEHOLDER/$DOMAIN/g" /tmp/nginx-ssl.conf

          scp -o StrictHostKeyChecking=no /tmp/nginx-ssl.conf root@"$DROPLET_IP":/etc/nginx/sites-available/tronrelic

          ssh root@"$DROPLET_IP" "ln -sf /etc/nginx/sites-available/tronrelic /etc/nginx/sites-enabled/tronrelic && rm -f /etc/nginx/sites-enabled/default && nginx -t && systemctl reload nginx"

          echo "âœ… Nginx configured with self-signed SSL"

          echo "âœ… Nginx setup complete with self-signed SSL certificate"

      - name: Copy docker-compose.yml to droplet
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"
          DEPLOY_DIR="/opt/tronrelic"

          echo "Copying docker-compose.yml to droplet..."
          scp -o StrictHostKeyChecking=no \
            docker-compose.yml \
            root@"$DROPLET_IP":"$DEPLOY_DIR/"

          echo "âœ… Docker compose configuration copied"

          # Verify it exists
          ssh -o StrictHostKeyChecking=no root@"$DROPLET_IP" \
            "ls -lh $DEPLOY_DIR/docker-compose.yml"

      - name: Create .env file on droplet
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"
          DEPLOY_DIR="/opt/tronrelic"
          IMAGE_TAG="${{ steps.prep.outputs.tag }}"
          ADMIN_TOKEN="${{ secrets.ADMIN_API_TOKEN }}"
          TRONGRID_KEY_1="${{ secrets.TRONGRID_API_KEY }}"
          TRONGRID_KEY_2="${{ secrets.TRONGRID_API_KEY_2 }}"
          TRONGRID_KEY_3="${{ secrets.TRONGRID_API_KEY_3 }}"

          echo "Generating secure secrets..."
          MONGO_PASSWORD=$(openssl rand -hex 32)
          REDIS_PASSWORD=$(openssl rand -hex 32)

          if [ "${{ steps.ip.outputs.using_reserved_ip }}" == "true" ]; then
            DOMAIN="${{ steps.ip.outputs.domain }}"
            SITE_URL="https://$DOMAIN"
            SITE_WS="https://$DOMAIN"
          else
            SITE_URL="http://$DROPLET_IP:3000"
            SITE_WS="http://$DROPLET_IP:4000"
          fi

          echo "Creating .env file..."
          {
            echo "# TronRelic Dev Environment - Auto-generated by GitHub Actions"
            echo "ENV=development"
            echo "SITE_URL=$SITE_URL"
            echo "SITE_WS=$SITE_WS"
            echo "SITE_BACKEND=http://backend:4000"
            echo "ADMIN_API_TOKEN=$ADMIN_TOKEN"
            echo "TRONGRID_API_KEY=$TRONGRID_KEY_1"
            echo "TRONGRID_API_KEY_2=$TRONGRID_KEY_2"
            echo "TRONGRID_API_KEY_3=$TRONGRID_KEY_3"
            echo "MONGO_ROOT_USERNAME=admin"
            echo "MONGO_ROOT_PASSWORD=$MONGO_PASSWORD"
            echo "REDIS_PASSWORD=$REDIS_PASSWORD"
            echo "PORT=4000"
            echo "ENABLE_SCHEDULER=true"
            echo "ENABLE_WEBSOCKETS=true"
            echo "REDIS_NAMESPACE=tronrelic"
            echo "IMAGE_TAG=$IMAGE_TAG"
          } > /tmp/dev.env

          scp -o StrictHostKeyChecking=no /tmp/dev.env root@"$DROPLET_IP":"$DEPLOY_DIR/.env"
          ssh -o StrictHostKeyChecking=no root@"$DROPLET_IP" "chmod 600 $DEPLOY_DIR/.env && ls -lh $DEPLOY_DIR/.env"
          rm /tmp/dev.env

          echo "âœ… Environment file created"

      - name: Authenticate with GitHub Container Registry
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"

          echo "Authenticating with GHCR on droplet..."
          echo "${{ secrets.GITHUB_TOKEN }}" | ssh -o StrictHostKeyChecking=no root@"$DROPLET_IP" \
            "docker login ghcr.io -u ${{ github.actor }} --password-stdin"

          echo "âœ… GHCR authentication successful"

      - name: Pull Docker images
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"
          DEPLOY_DIR="/opt/tronrelic"
          IMAGE_TAG="${{ steps.prep.outputs.tag }}"

          echo "Pulling Docker images with tag: $IMAGE_TAG"
          echo "This may take several minutes..."

          ssh -o StrictHostKeyChecking=no root@"$DROPLET_IP" \
            "cd $DEPLOY_DIR && docker compose pull"

          echo "âœ… Docker images pulled successfully"

      - name: Start containers
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"
          DEPLOY_DIR="/opt/tronrelic"

          echo "Starting containers..."
          ssh -o StrictHostKeyChecking=no root@"$DROPLET_IP" \
            "cd $DEPLOY_DIR && docker compose up -d"

          echo "Waiting for containers to start (30 seconds)..."
          sleep 30

          echo "Checking container status..."
          ssh -o StrictHostKeyChecking=no root@"$DROPLET_IP" \
            "cd $DEPLOY_DIR && docker compose ps"

          echo "âœ… Containers started successfully"

      - name: Verify deployment health
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_IP="${{ steps.ip.outputs.ip }}"

          if [ "${{ steps.ip.outputs.using_reserved_ip }}" == "true" ]; then
            DOMAIN="${{ steps.ip.outputs.domain }}"
            BACKEND_URL="https://$DOMAIN/api/health"
            FRONTEND_URL="https://$DOMAIN/"
            CURL_OPTS="-k"  # Allow self-signed cert
            echo "Checking health via Nginx (HTTPS with self-signed certificate)..."
          else
            BACKEND_URL="http://$DROPLET_IP:4000/api/health"
            FRONTEND_URL="http://$DROPLET_IP:3000/"
            CURL_OPTS=""
            echo "Checking health via direct IP (HTTP)..."
          fi

          echo "Checking backend health..."
          MAX_ATTEMPTS=10
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl $CURL_OPTS -f -s "$BACKEND_URL" > /dev/null 2>&1; then
              echo "âœ… Backend is healthy"
              break
            fi

            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - waiting 10s..."
            sleep 10
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "âš ï¸ Backend health check timed out (may still be starting)"
          fi

          echo "Checking frontend..."
          if curl $CURL_OPTS -f -s "$FRONTEND_URL" > /dev/null 2>&1; then
            echo "âœ… Frontend is responding"
          else
            echo "âš ï¸ Frontend not yet responding (may still be starting)"
          fi

      - name: Write workflow summary
        if: steps.check.outputs.exists == 'false'
        run: |
          DROPLET_NAME="${{ steps.prep.outputs.droplet_name }}"
          DROPLET_IP="${{ steps.ip.outputs.ip }}"
          DOMAIN="${{ steps.ip.outputs.domain }}"
          IMAGE_TAG="${{ steps.prep.outputs.tag }}"
          BACKEND_IMAGE="ghcr.io/${{ github.repository }}/backend:${IMAGE_TAG}"
          FRONTEND_IMAGE="ghcr.io/${{ github.repository }}/frontend:${IMAGE_TAG}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          USING_RESERVED_IP="${{ steps.ip.outputs.using_reserved_ip }}"

          if [ "$USING_RESERVED_IP" == "true" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âœ… Dev Environment Provisioned for PR #${PR_NUMBER}

          **âš ï¸ This droplet will auto-destroy when the PR is closed or merged**

          ### Droplet Information
          - **Name:** \`${DROPLET_NAME}\`
          - **Domain:** \`${DOMAIN}\`
          - **Reserved IP:** \`${DROPLET_IP}\`
          - **Lifespan:** Until PR #${PR_NUMBER} is closed/merged

          ### Docker Images
          - **Backend:** \`${BACKEND_IMAGE}\`
          - **Frontend:** \`${FRONTEND_IMAGE}\`

          ### SSH Access
          \`\`\`bash
          ssh root@${DROPLET_IP}
          \`\`\`

          ### Setup Status
          - âœ… Ubuntu 25.04 droplet created
          - âœ… Reserved IP (${DROPLET_IP}) assigned
          - âœ… Self-signed SSL certificate generated for ${DOMAIN}
          - âœ… Nginx reverse proxy configured
          - âœ… Docker and docker-compose installed
          - âœ… Deployment directory created (\`/opt/tronrelic\`)
          - âœ… Docker images pulled and containers started
          - âœ… Health checks passed

          ### Access Application
          - **Frontend:** https://${DOMAIN}/
          - **Backend API:** https://${DOMAIN}/api
          - **System Monitor:** https://${DOMAIN}/system

          **Note:**
          - Uses self-signed SSL certificate (browser will show warning - click through to proceed)
          - Traffic routed through Nginx reverse proxy (identical to production)
          - Containers may take 1-2 minutes to fully initialize
          - Reserved IP will be released when droplet is destroyed
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âœ… Dev Environment Provisioned for PR #${PR_NUMBER}

          **âš ï¸ Using dynamic IP (reserved IP in use by another PR)**
          **âš ï¸ This droplet will auto-destroy when the PR is closed or merged**

          ### Droplet Information
          - **Name:** \`${DROPLET_NAME}\`
          - **Dynamic IP:** \`${DROPLET_IP}\`
          - **Lifespan:** Until PR #${PR_NUMBER} is closed/merged

          ### Docker Images
          - **Backend:** \`${BACKEND_IMAGE}\`
          - **Frontend:** \`${FRONTEND_IMAGE}\`

          ### SSH Access
          \`\`\`bash
          ssh root@${DROPLET_IP}
          \`\`\`

          ### Setup Status
          - âœ… Ubuntu 25.04 droplet created
          - âš ï¸ Using dynamic IP (no domain, no SSL)
          - âœ… Docker and docker-compose installed
          - âœ… Deployment directory created (\`/opt/tronrelic\`)
          - âœ… Docker images pulled and containers started
          - âœ… Health checks passed

          ### Access Application
          - **Frontend:** http://${DROPLET_IP}:3000
          - **Backend API:** http://${DROPLET_IP}:4000/api
          - **System Monitor:** http://${DROPLET_IP}:3000/system

          **Note:**
          - Direct port access (no nginx reverse proxy)
          - HTTP only (no SSL certificate)
          - Containers may take 1-2 minutes to fully initialize
          EOF
          fi

          echo "âœ… Workflow summary written"

      - name: Post success comment on PR
        if: steps.check.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ github.event.pull_request.number }};
            const dropletIp = '${{ steps.ip.outputs.ip }}';
            const domain = '${{ steps.ip.outputs.domain }}';
            const imageTag = '${{ steps.prep.outputs.tag }}';
            const backendImage = `ghcr.io/${{ github.repository }}/backend:${imageTag}`;
            const frontendImage = `ghcr.io/${{ github.repository }}/frontend:${imageTag}`;
            const usingReservedIp = '${{ steps.ip.outputs.using_reserved_ip }}' === 'true';

            let comment;
            if (usingReservedIp) {
              comment = `## âœ… Dev Environment provisioned for PR #${prNumber}

            **âš ï¸ This droplet will auto-destroy when the PR is closed or merged**

            **Droplet Information:**
            - **Name:** \`tronrelic-main-pr-${prNumber}\`
            - **Domain:** \`${domain}\`
            - **Reserved IP:** \`${dropletIp}\`
            - **Lifespan:** Until PR #${prNumber} is closed/merged

            **Docker Images:**
            - **Backend:** \`${backendImage}\`
            - **Frontend:** \`${frontendImage}\`

            **SSH Access:**
            \`\`\`bash
            ssh root@${dropletIp}
            \`\`\`

            **Setup Status:**
            - âœ… Ubuntu 25.04 droplet created
            - âœ… Reserved IP (${dropletIp}) assigned
            - âœ… Self-signed SSL certificate generated for ${domain}
            - âœ… Nginx reverse proxy configured
            - âœ… Docker and docker-compose installed
            - âœ… Deployment directory created (\`/opt/tronrelic\`)
            - âœ… Docker images pulled and containers started
            - âœ… Health checks passed

            **Access Application:**
            - **Frontend:** https://${domain}/
            - **Backend API:** https://${domain}/api
            - **System Monitor:** https://${domain}/system

            **Note:**
            - Uses self-signed SSL certificate (browser will show warning - click through to proceed)
            - Traffic routed through Nginx reverse proxy (identical to production)
            - Containers may take 1-2 minutes to fully initialize
            `;
            } else {
              comment = `## âœ… Dev Environment provisioned for PR #${prNumber}

            **âš ï¸ Using dynamic IP (reserved IP in use by another PR)**
            **âš ï¸ This droplet will auto-destroy when the PR is closed or merged**

            **Droplet Information:**
            - **Name:** \`tronrelic-main-pr-${prNumber}\`
            - **Dynamic IP:** \`${dropletIp}\`
            - **Lifespan:** Until PR #${prNumber} is closed/merged

            **Docker Images:**
            - **Backend:** \`${backendImage}\`
            - **Frontend:** \`${frontendImage}\`

            **SSH Access:**
            \`\`\`bash
            ssh root@${dropletIp}
            \`\`\`

            **Setup Status:**
            - âœ… Ubuntu 25.04 droplet created
            - âš ï¸ Using dynamic IP (no domain, no SSL)
            - âœ… Docker and docker-compose installed
            - âœ… Deployment directory created (\`/opt/tronrelic\`)
            - âœ… Docker images pulled and containers started
            - âœ… Health checks passed

            **Access Application:**
            - **Frontend:** http://${dropletIp}:3000
            - **Backend API:** http://${dropletIp}:4000/api
            - **System Monitor:** http://${dropletIp}:3000/system

            **Note:**
            - Direct port access (no nginx reverse proxy)
            - HTTP only (no SSL certificate)
            - Containers may take 1-2 minutes to fully initialize
            `;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });
