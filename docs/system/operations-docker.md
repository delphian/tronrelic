# TronRelic Docker Standards

## Overview

TronRelic uses a **unified Docker deployment system** where environment differentiation is controlled entirely by the `ENV` variable in the .env file. All environments share identical container names, deployment directories, and Docker Compose configuration.

## Core Principles

### Single ENV Variable Controls Everything

Environment behavior is controlled by **one variable only**:
- `ENV=development` - PR testing environments (ephemeral, automated)
- `ENV=production` - Production deployment (permanent, manual)

This variable controls:
- Node.js runtime (`NODE_ENV=development` or `NODE_ENV=production`)
- Feature flags and logging levels
- All environment-specific behavior

**What it does NOT control:**
- Container names (always the same: `tronrelic-backend`, `tronrelic-frontend`, etc.)
- Deployment directory (always `/opt/tronrelic`)
- Docker Compose file structure (unified across all environments)

### Universal Docker Images

**Key principle:** Docker images are environment-agnostic. The same image works in any environment.

**Production deployments use `:production` tags:**
```yaml
services:
  backend:
    image: ghcr.io/delphian/tronrelic/backend:production
  frontend:
    image: ghcr.io/delphian/tronrelic/frontend:production
```

**PR testing environments use `:dev-{sha}` tags:**
```yaml
services:
  backend:
    image: ghcr.io/delphian/tronrelic/backend:dev-a1b2c3d
  frontend:
    image: ghcr.io/delphian/tronrelic/frontend:dev-a1b2c3d
```

**Runtime configuration makes images universal:**
- Frontend fetches configuration from backend API at server-side render time
- No build-time URL injection via `NEXT_PUBLIC_*` environment variables
- Single image works on any domain (`tronrelic.com`, `pr-42.dev-pr.tronrelic.com`, `localhost:3000`)

### Implementation

**docker-compose.yml (unified for all environments):**
```yaml
services:
  backend:
    image: ghcr.io/delphian/tronrelic/backend:production
    container_name: tronrelic-backend
    environment:
      - NODE_ENV=${ENV}
    ports:
      - "127.0.0.1:4000:4000"  # Localhost only (Nginx proxies)

  frontend:
    image: ghcr.io/delphian/tronrelic/frontend:production
    container_name: tronrelic-frontend
    environment:
      - NODE_ENV=${ENV}
    ports:
      - "127.0.0.1:3000:3000"  # Localhost only (Nginx proxies)

  mongodb:
    image: mongo:7
    container_name: tronrelic-mongo
    command: ["mongod", "--auth"]
    volumes:
      - tronrelic-mongo-data:/data/db
    # No ports exposed externally (Docker network only)

  redis:
    image: redis:7-alpine
    container_name: tronrelic-redis
    command: ["redis-server", "--requirepass", "${REDIS_PASSWORD}"]
    volumes:
      - tronrelic-redis-data:/data
    # No ports exposed externally (Docker network only)
```

**Production .env file:**
```bash
ENV=production
SITE_URL=https://tronrelic.com
SITE_WS=https://tronrelic.com
SITE_BACKEND=http://backend:4000
```

**PR testing .env file (automatically generated by GitHub Actions):**
```bash
ENV=development
SITE_URL=https://pr-42.dev-pr.tronrelic.com
SITE_WS=https://pr-42.dev-pr.tronrelic.com
SITE_BACKEND=http://backend:4000
```

## Naming Conventions

### Container Names (Identical Across All Environments)

All environments use **identical container names** (no `-prod` or `-dev` suffixes):

| Service | Container Name | Reason |
|---------|----------------|--------|
| Backend | `tronrelic-backend` | Simplifies scripts and monitoring |
| Frontend | `tronrelic-frontend` | No environment-specific references needed |
| MongoDB | `tronrelic-mongo` | Consistent backup/restore procedures |
| Redis | `tronrelic-redis` | Unified debugging commands |

**Benefits:**
- Scripts work across all environments without modification
- Consistent monitoring and debugging commands
- No environment-specific container references needed
- Simplified deployment procedures

### Volume Names (Identical Across All Environments)

All environments use **identical volume names**:
- `tronrelic-mongo-data`
- `tronrelic-redis-data`

**Benefits:** Consistent backup/restore procedures, simplified volume management.

### Deployment Directory (Identical Across All Environments)

All servers deploy to the **same directory**:
```bash
/opt/tronrelic/
```

**Contents:**
```
/opt/tronrelic/
├── .env                    # Environment-specific configuration (ENV, URLs, secrets)
├── docker-compose.yml      # Unified for all environments
└── (volumes managed by Docker)
```

Environment differentiation is **entirely controlled by .env file content**, not directory paths or container names.

## Image Tagging Convention

### Production Images

**GitHub Actions workflow (.github/workflows/prod-publish.yml):**
- **Trigger:** Push to `main` branch
- **Tags:** `:production` and `:production-{sha}` (for rollback)

```yaml
- name: Build and push production images
  run: |
    docker build --target backend -t ghcr.io/delphian/tronrelic/backend:production .
    docker build --target backend -t ghcr.io/delphian/tronrelic/backend:production-${{ github.sha }} .
    docker push ghcr.io/delphian/tronrelic/backend:production
    docker push ghcr.io/delphian/tronrelic/backend:production-${{ github.sha }}
```

### PR Testing Images

**GitHub Actions workflow (.github/workflows/pr-environment.yml):**
- **Trigger:** Opening PR to `main` branch
- **Tags:** `:dev-{short-sha}` (unique per PR branch)

```yaml
- name: Build and push PR testing images
  run: |
    SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
    docker build --target backend -t ghcr.io/delphian/tronrelic/backend:dev-${SHORT_SHA} .
    docker push ghcr.io/delphian/tronrelic/backend:dev-${SHORT_SHA}
```

**Why branch-specific tags for PR environments:**
- Each PR tests different code (different features, bug fixes)
- Prevents image collision between concurrent PRs
- Enables testing specific commits without rebuilding

## Port Binding and Security

### Security Architecture

**Problem:** Docker bypasses UFW firewall by manipulating iptables directly. Even if you block a port in UFW, Docker-published ports remain accessible.

**Solution:** Bind application ports to `127.0.0.1` (localhost only) in docker-compose.yml:

```yaml
services:
  backend:
    ports:
      - "127.0.0.1:4000:4000"  # Only accessible via localhost
  frontend:
    ports:
      - "127.0.0.1:3000:3000"  # Only accessible via localhost
  mongodb:
    # No ports section - Docker network only
  redis:
    # No ports section - Docker network only
```

**Nginx reverse proxy** (the only externally accessible service):
```nginx
server {
    listen 80;
    listen 443 ssl;
    server_name tronrelic.com;

    location /api {
        proxy_pass http://localhost:4000;  # Proxies to backend on localhost
    }

    location / {
        proxy_pass http://localhost:3000;  # Proxies to frontend on localhost
    }
}
```

### Port Layout

**Externally accessible (via UFW and Nginx):**
- **22/tcp** - SSH access (UFW managed)
- **80/tcp** - HTTP (UFW managed, redirects to HTTPS)
- **443/tcp** - HTTPS (UFW managed, Nginx reverse proxy)

**Localhost only (Docker bound to 127.0.0.1):**
- **3000/tcp** - Frontend (Nginx proxies via localhost)
- **4000/tcp** - Backend API (Nginx proxies via localhost)

**Internal only (no port binding, Docker network only):**
- **27017/tcp** - MongoDB (accessible only from backend container)
- **6379/tcp** - Redis (accessible only from backend container)

## Runtime Configuration System

### Why Runtime Config Instead of Build-time Injection

**Traditional approach (NEXT_PUBLIC_* variables):**
```dockerfile
# Build-time injection (old approach)
ENV NEXT_PUBLIC_API_URL=https://tronrelic.com/api
ENV NEXT_PUBLIC_WS_URL=https://tronrelic.com
```

**Problems:**
- Requires rebuilding images for every domain change
- Cannot use same image on different domains
- PR environments would need unique builds
- Local development requires separate images

**TronRelic approach (runtime configuration):**
```typescript
// Frontend fetches config from backend at SSR time
const config = await fetch('http://backend:4000/api/config/public').then(r => r.json())
// Returns: { apiUrl: 'https://tronrelic.com/api', wsUrl: 'https://tronrelic.com' }
```

**Benefits:**
- Single image works on any domain without rebuilding
- PR environments use production images with different runtime config
- Localhost development uses same images as production
- Configuration controlled by server .env file, not Docker image

## Environment Examples

### Production Environment

**Server:** Permanent Digital Ocean droplet
**Domain:** tronrelic.com
**Deployment:** Manual using `./scripts/droplet-update.sh prod`
**Lifespan:** Permanent

**Production .env:**
```bash
ENV=production
SITE_URL=https://tronrelic.com
SITE_WS=https://tronrelic.com
SITE_BACKEND=http://backend:4000

ADMIN_API_TOKEN=<generated-token>
MONGO_ROOT_PASSWORD=<generated-password>
REDIS_PASSWORD=<generated-password>
TRONGRID_API_KEY=<key-1>
TRONGRID_API_KEY_2=<key-2>
TRONGRID_API_KEY_3=<key-3>
```

**Docker images:**
```yaml
backend: ghcr.io/delphian/tronrelic/backend:production
frontend: ghcr.io/delphian/tronrelic/frontend:production
```

### PR Testing Environment

**Server:** Temporary Digital Ocean droplet (auto-created per PR)
**Domain:** pr-{number}.dev-pr.tronrelic.com (e.g., pr-42.dev-pr.tronrelic.com)
**Deployment:** Fully automated via GitHub Actions
**Lifespan:** Until PR is closed or merged

**PR testing .env (auto-generated by GitHub Actions):**
```bash
ENV=development
SITE_URL=https://pr-42.dev-pr.tronrelic.com
SITE_WS=https://pr-42.dev-pr.tronrelic.com
SITE_BACKEND=http://backend:4000

ADMIN_API_TOKEN=<from-github-secrets>
MONGO_ROOT_PASSWORD=<auto-generated>
REDIS_PASSWORD=<auto-generated>
TRONGRID_API_KEY=<from-github-secrets>
TRONGRID_API_KEY_2=<from-github-secrets>
TRONGRID_API_KEY_3=<from-github-secrets>
```

**Docker images:**
```yaml
backend: ghcr.io/delphian/tronrelic/backend:dev-a1b2c3d
frontend: ghcr.io/delphian/tronrelic/frontend:dev-a1b2c3d
```

## Benefits of Unified System

**Maximum simplicity:** All environments use same container names, deployment directory, and Docker Compose file. Only .env differs.

**Universal images:** Single Docker image works on any domain without rebuilding (via runtime configuration).

**Industry alignment:** Uses Node.js standard `NODE_ENV` conventions (development/production) instead of custom naming schemes.

**Single source of truth:** ENV variable in .env file determines runtime behavior—impossible to have mismatched configuration.

**Clear intent:** `development` and `production` are explicit and unambiguous, unlike abbreviations or aliases.

**Consistent tooling:** Same Docker commands work across all environments without environment-specific flags.

**Simplified scripts:** Deployment scripts don't need environment-specific logic for container names or paths.

## Security Checklist

**Required secrets (generate with `openssl rand -hex 32`):**
- `ADMIN_API_TOKEN` - Access to /system monitoring endpoint
- `MONGO_ROOT_PASSWORD` - MongoDB authentication
- `REDIS_PASSWORD` - Redis authentication

**Best practices:**
- [ ] Never commit .env files to version control
- [ ] Use strong, unique passwords for each environment
- [ ] Rotate credentials periodically
- [ ] Enable authentication on all remote deployments (`--auth` for MongoDB, `--requirepass` for Redis)
- [ ] Use TLS/SSL for all remote deployments (HTTP for localhost development only)
- [ ] Bind application ports to `127.0.0.1` (not `0.0.0.0`)
- [ ] Keep databases internal to Docker network (no port binding)

## Quick Reference

### Environment Variables

| Variable | Production | PR Testing |
|----------|------------|------------|
| `ENV` | `production` | `development` |
| `SITE_URL` | `https://tronrelic.com` | `https://pr-{number}.dev-pr.tronrelic.com` |
| `NODE_ENV` | `production` (auto-set) | `development` (auto-set) |

### Image Tags

| Environment | Backend | Frontend |
|------------|---------|----------|
| Production | `ghcr.io/delphian/tronrelic/backend:production` | `ghcr.io/delphian/tronrelic/frontend:production` |
| PR Testing | `ghcr.io/delphian/tronrelic/backend:dev-{sha}` | `ghcr.io/delphian/tronrelic/frontend:dev-{sha}` |

### Container Names (Identical for All Environments)

- `tronrelic-backend`
- `tronrelic-frontend`
- `tronrelic-mongo`
- `tronrelic-redis`

### Deployment Directory (Identical for All Environments)

```bash
/opt/tronrelic/
```

## Troubleshooting

**Images not updating after deployment:**
- Run `docker compose pull` to fetch latest images
- Check that CI/CD successfully pushed new images to GHCR
- Verify image digest: `docker image inspect ghcr.io/delphian/tronrelic/backend:production`

**Wrong runtime behavior:**
- Check `ENV` value in .env file (must be exactly `development` or `production`)
- Verify container picked up ENV: `docker exec tronrelic-backend env | grep NODE_ENV`
- Restart containers if ENV was changed: `docker compose restart`

**Container name conflicts:**
- Stop old containers: `docker stop tronrelic-backend tronrelic-frontend`
- Remove old containers: `docker rm tronrelic-backend tronrelic-frontend`
- Remove old networks if needed: `docker network prune`

**Authentication failures:**
- Verify `MONGO_ROOT_PASSWORD` and `REDIS_PASSWORD` are set in .env
- Check connection strings include credentials
- Ensure MongoDB started with `--auth` flag
- Ensure Redis started with `--requirepass` flag

**Runtime configuration not loading:**
- Verify backend health: `curl http://localhost:4000/api/config/public`
- Check frontend SSR logs for config fetch errors
- Ensure `SITE_URL` is set correctly in .env
- Verify backend container can be reached at `http://backend:4000` from frontend container

**Port access issues:**
- Verify ports bound to `127.0.0.1` in docker-compose.yml (not `0.0.0.0`)
- Check Nginx reverse proxy configuration
- Use SSH port forwarding for remote debugging: `ssh -L 3000:localhost:3000 root@<ip>`

## Further Reading

**Related documentation:**
- [system-runtime-config.md](./system-runtime-config.md) - Runtime configuration system architecture
- [environment.md](../environment.md) - Complete environment variable reference
- [README.md - Docker Quick Start](../../README.md#docker-quick-start) - Local development with Docker
